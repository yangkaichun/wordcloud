<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>國家衛生研究院智慧醫療文字雲生成器</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --accent-color: #9b59b6;
            --background-color: #f5f7fa;
            --card-color: #ffffff;
            --text-color: #2c3e50;
            --border-color: #e2e8f0;
        }

        body {
            font-family: 'Microsoft YaHei', 'PingFang TC', 'Heiti TC', 'Apple LiGothic Medium', 'STHeiti', 'Source Han Sans TC', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            overflow-x: hidden;
        }

        .gradient-border {
            position: relative;
            border-radius: 10px;
            padding: 5px;
        }

        .gradient-border::after {
            content: "";
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color), var(--accent-color));
            border-radius: 12px;
            z-index: -1;
            opacity: 0.7;
        }

        .tech-card {
            background-color: var(--card-color);
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.08);
            position: relative;
            overflow: hidden;
        }

        .tech-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -50%;
            width: 200%;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(52, 152, 219, 0.5), transparent);
            animation: techScan 4s linear infinite;
        }

        @keyframes techScan {
            0% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(100vh);
            }
            100% {
                transform: translateY(0);
            }
        }

        .btn-tech {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            font-weight: 600;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
            z-index: 1;
        }

        .btn-tech:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }

        .btn-tech::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: all 0.5s ease;
            z-index: -1;
        }

        .btn-tech:hover::after {
            left: 100%;
        }

        .cloud-container {
            border: 2px solid rgba(52, 152, 219, 0.3);
            border-radius: 50%/30%;
            position: relative;
            overflow: hidden;
            background-color: rgba(255, 255, 255, 0.6);
            box-shadow: inset 0 0 30px rgba(52, 152, 219, 0.1);
        }

        .cloud-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, 
                rgba(52, 152, 219, 0.05) 0%, 
                rgba(46, 204, 113, 0.05) 50%, 
                rgba(155, 89, 182, 0.05) 100%);
            pointer-events: none;
        }

        .loading-indicator {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
        }

        .loading-spinner {
            border: 4px solid rgba(52, 152, 219, 0.3);
            border-radius: 50%;
            border-top: 4px solid var(--primary-color);
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .logo {
            height: 60px;
            object-fit: contain;
        }

        .grid-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(52, 152, 219, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(52, 152, 219, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            z-index: -1;
        }

        .pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
        }

        /* Add any other styles you need for your word cloud here */
    </style>
</head>
<body>
    <div class="grid-bg"></div>
    <div class="container mx-auto px-4 py-6">
        <div class="tech-card p-6 mb-8">
            <!-- Logo area - will attempt to load icon.png from the same directory -->
            <div class="flex justify-between items-center mb-6">
                <div class="flex items-center">
                    <img id="logoImage" src="icon.png" alt="國家衛生研究院" class="logo mr-3" onerror="this.onerror=null; this.src='https://cdn.jsdelivr.net/gh/microsoft/fluentui-system-icons/assets/Research/SVG/ic_fluent_research_24_regular.svg'; this.style.height='40px';">
                    <h1 class="text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-500 to-green-500">國家衛生研究院智慧醫療文字雲生成器</h1>
                </div>
            </div>
            
            <!-- Controls -->
            <div class="flex flex-wrap gap-4 mb-6">
                <div class="gradient-border">
                    <input type="file" id="fileInput" accept=".xlsx, .xls" class="hidden" />
                    <button id="fileSelectBtn" class="btn-tech">選擇Excel檔案</button>
                </div>
                <div class="gradient-border">
                    <button id="generateKeywordBtn" class="btn-tech">產生關鍵詞文字雲</button>
                </div>
                <div class="gradient-border">
                    <button id="generateSentenceBtn" class="btn-tech">產生整句話簡化語意</button>
                </div>
            </div>
            
            <!-- Status display -->
            <div id="fileStatus" class="mb-4 text-gray-600"></div>
        </div>
        
        <!-- Word cloud container -->
        <div class="cloud-container w-full" style="height: 70vh; min-height: 400px;">
            <canvas id="wordCloudCanvas" width="800" height="600"></canvas>
            <div class="loading-indicator" id="loadingIndicator">
                <div class="loading-spinner"></div>
                <div class="mt-3 text-center text-blue-600">處理中...</div>
            </div>
        </div>
    </div>
    
    <script>
        // Global variables
        let excelData = [];
        let wordCloudWords = [];
        let canvas = document.getElementById('wordCloudCanvas');
        let ctx = canvas.getContext('2d');
        let wordObjects = [];
        let animationId;
        let fileInput = document.getElementById('fileInput');
        let fileSelectBtn = document.getElementById('fileSelectBtn');
        let generateKeywordBtn = document.getElementById('generateKeywordBtn');
        let generateSentenceBtn = document.getElementById('generateSentenceBtn');
        let fileStatus = document.getElementById('fileStatus');
        let loadingIndicator = document.getElementById('loadingIndicator');
        
        // Common Chinese stopwords
        const stopwords = new Set([
            '的', '了', '和', '是', '在', '我', '有', '就', '不', '人', '都', '一', '一個', '上', '也', '很', '到', '說', '要', '去',
            '你', '會', '著', '沒有', '看', '好', '自己', '這', '會', '但', '那', '怎麼', '他', '她', '它', '這個', '那個', '什麼',
            '為什麼', '如何', '可以', '因為', '所以', '可能', '應該', '於', '地', '能', '然後', '再', '得', '吧', '呢', '啊', '喔',
            '嗎', '啦', '吶', '咧', '就是', '還是', '還有', '只是', '只有', '而已', '一樣', '一直', '一般', '這樣', '那樣', '如果',
            '的話', '來', '把', '被', '讓', '使', '從', '對', '給', '向', '跟', '當', '做', '想', '要', '用', '時', '才', '已經', '曾經'
        ]);

        // Initialize the canvas and resize handler
        function initCanvas() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }

        // Resize canvas to fit its container
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            // Redraw word cloud if we have data
            if (wordObjects.length > 0) {
                drawWordCloud();
            }
        }

        // Load Excel file from URL or local file
        async function loadExcel(file) {
            showLoading(true);
            fileStatus.textContent = "讀取Excel檔案中...";
            
            try {
                let data;
                if (typeof file === 'string') {
                    // Load from URL
                    const response = await fetch(file);
                    if (!response.ok) {
                        throw new Error(`無法載入檔案: ${response.statusText}`);
                    }
                    const arrayBuffer = await response.arrayBuffer();
                    data = new Uint8Array(arrayBuffer);
                } else {
                    // Load from file input
                    const arrayBuffer = await file.arrayBuffer();
                    data = new Uint8Array(arrayBuffer);
                }
                
                // Parse Excel data
                const workbook = XLSX.read(data, { type: 'array' });
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
                
                // Extract first column data, skipping header row if it exists
                const firstColData = jsonData
                    .filter(row => row.length > 0 && row[0] !== undefined && row[0] !== null)
                    .map(row => String(row[0]));
                
                if (firstColData.length === 0) {
                    throw new Error("Excel檔案中沒有找到資料");
                }
                
                excelData = firstColData;
                fileStatus.textContent = `已載入 ${excelData.length} 筆資料`;
                
                return firstColData;
            } catch (error) {
                console.error("Excel檔案處理錯誤:", error);
                fileStatus.textContent = `Excel檔案處理錯誤: ${error.message}`;
                showLoading(false);
                throw error;
            }
        }

        // Simple Chinese word segmentation
        function segmentChinese(text) {
            // Remove all non-Chinese characters (including English and numbers)
            const chineseOnly = text.replace(/[^\u4e00-\u9fa5]/g, ' ').trim();
            
            // N-gram approach (2-gram and 3-gram) for Chinese text
            let words = [];
            
            // 2-gram
            for (let i = 0; i < chineseOnly.length - 1; i++) {
                const twoGram = chineseOnly.substring(i, i + 2);
                if (twoGram.trim().length === 2) {
                    words.push(twoGram);
                }
            }
            
            // 3-gram
            for (let i = 0; i < chineseOnly.length - 2; i++) {
                const threeGram = chineseOnly.substring(i, i + 3);
                if (threeGram.trim().length === 3) {
                    words.push(threeGram);
                }
            }
            
            // 4-gram for longer phrases
            for (let i = 0; i < chineseOnly.length - 3; i++) {
                const fourGram = chineseOnly.substring(i, i + 4);
                if (fourGram.trim().length === 4) {
                    words.push(fourGram);
                }
            }
            
            // Filter out stopwords and single characters
            return words.filter(word => 
                word.length >= 2 && 
                !stopwords.has(word) && 
                !/[a-zA-Z0-9]/.test(word)
            );
        }

        // Process text for keyword extraction
        function processForKeywords(textArray) {
            showLoading(true);
            
            // Segment and count all words
            let wordFreq = {};
            let totalWords = 0;
            
            textArray.forEach(text => {
                const words = segmentChinese(text);
                words.forEach(word => {
                    // Skip single character words
                    if (word.length < 2) return;
                    
                    // Skip words with English or numbers
                    if (/[a-zA-Z0-9]/.test(word)) return;
                    
                    if (!wordFreq[word]) {
                        wordFreq[word] = 0;
                    }
                    wordFreq[word]++;
                    totalWords++;
                });
            });
            
            // Sort by frequency
            const wordFreqArray = Object.entries(wordFreq)
                .filter(([word, count]) => count > 0)
                .sort((a, b) => b[1] - a[1]);
            
            // Take top 100 words or fewer if there aren't that many
            const topWords = wordFreqArray.slice(0, 100);
            
            // Create word cloud data
            const maxFreq = topWords.length > 0 ? topWords[0][1] : 1;
            
            wordCloudWords = topWords.map(([word, count]) => ({
                text: word,
                size: 14 + (count / maxFreq) * 56, // Size from 14 to 70
                freq: count
            }));
            
            showLoading(false);
            return wordCloudWords;
        }

        // Process text for sentence simplification
        function processForSentences(textArray) {
            showLoading(true);
            
            // Filter non-Chinese content and simplify sentences
            const simplifiedSentences = textArray
                .map(text => {
                    // Remove English and numbers
                    return text.replace(/[a-zA-Z0-9]+/g, '').trim();
                })
                .filter(text => text.length > 0);
            
            // Count sentence frequencies
            let sentenceFreq = {};
            simplifiedSentences.forEach(sentence => {
                if (!sentenceFreq[sentence]) {
                    sentenceFreq[sentence] = 0;
                }
                sentenceFreq[sentence]++;
            });
            
            // Sort by frequency
            const sentenceFreqArray = Object.entries(sentenceFreq)
                .sort((a, b) => b[1] - a[1]);
            
            // Take top 50 sentences or fewer if there aren't that many
            const topSentences = sentenceFreqArray.slice(0, 50);
            
            // Create word cloud data for sentences
            const maxFreq = topSentences.length > 0 ? topSentences[0][1] : 1;
            
            wordCloudWords = topSentences.map(([sentence, count]) => ({
                text: sentence,
                size: 14 + (count / maxFreq) * 36, // Size from 14 to 50, smaller for sentences
                freq: count
            }));
            
            showLoading(false);
            return wordCloudWords;
        }

        // Initialize word cloud objects for animation
        function initWordCloud(words) {
            stopAnimation();
            
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Create objects for each word
            wordObjects = words.map(word => {
                // Randomize position, but avoid edges initially
                const padding = word.size;
                const x = Math.random() * (canvasWidth - padding * 2) + padding;
                const y = Math.random() * (canvasHeight - padding * 2) + padding;
                
                // Randomize movement
                const speedMultiplier = 0.5;
                const dx = (Math.random() * 2 - 1) * speedMultiplier;
                const dy = (Math.random() * 2 - 1) * speedMultiplier;
                
                // Randomize color
                const hue = Math.random() * 360;
                const saturation = 70 + Math.random() * 30;
                const lightness = 40 + Math.random() * 20;
                const color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                
                // Randomize font
                const fonts = [
                    "'Microsoft YaHei'", "'PingFang TC'", "'Heiti TC'", 
                    "'STHeiti'", "'Source Han Sans TC'", "'Noto Sans TC'", 
                    "'Microsoft JhengHei'", "'DFKai-SB'"
                ];
                const font = fonts[Math.floor(Math.random() * fonts.length)];
                
                return {
                    text: word.text,
                    x,
                    y,
                    dx,
                    dy,
                    size: word.size,
                    color,
                    font
                };
            });
            
            startAnimation();
        }

        // Start word cloud animation
        function startAnimation() {
            if (!animationId) {
                animate();
            }
        }

        // Stop word cloud animation
        function stopAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        // Animate word cloud
        function animate() {
            animationId = requestAnimationFrame(animate);
            drawWordCloud();
        }

        // Draw word cloud on canvas
        function drawWordCloud() {
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            // Calculate ellipse parameters
            const ellipseWidth = canvasWidth * 0.95;
            const ellipseHeight = canvasHeight * 0.9;
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            
            // Move and draw each word
            wordObjects.forEach(obj => {
                // Move word
                obj.x += obj.dx;
                obj.y += obj.dy;
                
                // Set font
                ctx.font = `bold ${obj.size}px ${obj.font}, sans-serif`;
                ctx.fillStyle = obj.color;
                
                // Measure text
                const textWidth = ctx.measureText(obj.text).width;
                const textHeight = obj.size; // Approximation
                
                // Check ellipse boundaries
                const halfWidth = textWidth / 2;
                const halfHeight = textHeight / 2;
                
                // Test if word is outside ellipse
                const normalizedX = (obj.x - centerX) / (ellipseWidth / 2);
                const normalizedY = (obj.y - centerY) / (ellipseHeight / 2);
                const distanceSquared = normalizedX * normalizedX + normalizedY * normalizedY;
                
                if (distanceSquared > 0.9) { // 0.9 to account for text size
                    // Bounce back from boundary
                    // Calculate normal vector
                    const nx = normalizedX / Math.sqrt(distanceSquared);
                    const ny = normalizedY / Math.sqrt(distanceSquared);
                    
                    // Reflect velocity vector
                    const dotProduct = obj.dx * nx + obj.dy * ny;
                    obj.dx = obj.dx - 2 * dotProduct * nx;
                    obj.dy = obj.dy - 2 * dotProduct * ny;
                    
                    // Move word back inside boundary
                    const angle = Math.atan2(normalizedY, normalizedX);
                    obj.x = centerX + (ellipseWidth / 2 - halfWidth) * 0.9 * Math.cos(angle);
                    obj.y = centerY + (ellipseHeight / 2 - halfHeight) * 0.9 * Math.sin(angle);
                }
                
                // Also check for window boundaries
                if (obj.x - halfWidth < 0 || obj.x + halfWidth > canvasWidth) {
                    obj.dx = -obj.dx;
                    obj.x = Math.max(halfWidth, Math.min(canvasWidth - halfWidth, obj.x));
                }
                
                if (obj.y - halfHeight < 0 || obj.y + halfHeight > canvasHeight) {
                    obj.dy = -obj.dy;
                    obj.y = Math.max(halfHeight, Math.min(canvasHeight - halfHeight, obj.y));
                }
                
                // Draw word
                ctx.fillText(obj.text, obj.x - halfWidth, obj.y + halfHeight / 2);
            });
        }

        // Show or hide loading indicator
        function showLoading(show) {
            loadingIndicator.style.display = show ? 'block' : 'none';
        }

        // Try to load default file
        async function tryLoadDefaultFile() {
            try {
                const data = await loadExcel('demo.xlsx');
                generateKeywordCloud(); // Generate keyword cloud by default
                return true;
            } catch (error) {
                console.log("Default file not loaded:", error);
                fileStatus.textContent = "請選擇Excel檔案開始使用";
                return false;
            }
        }

        // Generate keyword cloud
        async function generateKeywordCloud() {
            if (excelData.length === 0) {
                fileStatus.textContent = "請先選擇Excel檔案";
                return;
            }
            
            showLoading(true);
            fileStatus.textContent = "生成關鍵詞文字雲中...";
            
            const words = processForKeywords(excelData);
            if (words.length === 0) {
                fileStatus.textContent = "未找到有效的關鍵詞";
                showLoading(false);
                return;
            }
            
            initWordCloud(words);
            fileStatus.textContent = `已生成 ${words.length} 個關鍵詞的文字雲`;
        }

        // Generate sentence cloud
        async function generateSentenceCloud() {
            if (excelData.length === 0) {
                fileStatus.textContent = "請先選擇Excel檔案";
                return;
            }
            
            showLoading(true);
            fileStatus.textContent = "生成整句話簡化語意文字雲中...";
            
            const sentences = processForSentences(excelData);
            if (sentences.length === 0) {
                fileStatus.textContent = "未找到有效的語句";
                showLoading(false);
                return;
            }
            
            initWordCloud(sentences);
            fileStatus.textContent = `已生成 ${sentences.length} 個簡化語句的文字雲`;
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            initCanvas();
            
            // Fix file selection
            fileSelectBtn.addEventListener('click', function() {
                fileInput.click();
            });
            
            // Make sure file input event works
            fileInput.addEventListener('change', async function(e) {
                if (this.files && this.files[0]) {
                    try {
                        await loadExcel(this.files[0]);
                        generateKeywordCloud();
                    } catch (error) {
                        console.error("Error processing file:", error);
                    }
                }
            });
            
            // Attach event listeners to buttons
            generateKeywordBtn.addEventListener('click', generateKeywordCloud);
            generateSentenceBtn.addEventListener('click', generateSentenceCloud);
            
            // Try to load default file
            tryLoadDefaultFile();
        });
    </script>
</body>
</html>
