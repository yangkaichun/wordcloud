<!DOCTYPE html>
<html>
<head>
    <title>動態文字雲產生器</title>
    <style>
        body {
            font-family: sans-serif;
        }
        #wordCloudContainer {
            width: 100%; /* 或 80%，根據您的需求 */
            height: 600px; /* 或 90%，根據您的需求 */
            border: 0px solid #ccc;
            position: relative;
            overflow: hidden;
            background-color: #fff; /* 白色 */
            border-radius: 50%; /* 使方框變為橢圓形 */
            display: flex; /* 確保內容居中，視覺效果更佳 */
            justify-content: center;
            align-items: center;
        }
        .shattered-word {
            position: absolute;
            font-family: "Microsoft YaHei", sans-serif; /* 設定統一字形為微軟正黑體，若找不到則使用 sans-serif */
        }
        .shattered-letter {
            display: inline-block;
            font-size: inherit;
            font-weight: inherit;
            color: inherit;
            position: relative; /* 允許內部微調位置 */
        }
    </style>
</head>
<body>
    <input type="file" id="excelFile" accept=".xlsx, .xls">
    <button id="generateButton" disabled>產生文字雲</button>
    <div id="wordCloudContainer"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
        const fileInput = document.getElementById('excelFile');
        const generateButton = document.getElementById('generateButton');
        const wordCloudContainer = document.getElementById('wordCloudContainer');
        let excelData = [];

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    const range = XLSX.utils.decode_range(worksheet['!ref']);
                    excelData = [];
                    for (let rowNum = range.s.r; rowNum <= range.e.r; rowNum++) {
                        const cellAddress = XLSX.utils.encode_cell({ r: rowNum, c: 0 });
                        const cell = worksheet[cellAddress];
                        if (cell && cell.v) {
                            excelData.push(cell.v);
                        }
                    }
                    if (excelData.length > 0) {
                        generateButton.disabled = false;
                    } else {
                        generateButton.disabled = true;
                        alert("Excel檔案的第一欄沒有內容。");
                    }
                };
                reader.readAsArrayBuffer(file);
            } else {
                generateButton.disabled = true;
                excelData = [];
            }
        });

        generateButton.addEventListener('click', () => {
            wordCloudContainer.innerHTML = ''; // 清空之前的文字雲
            const words = {};
            excelData.forEach(text => {
                // 簡單的詞彙判斷
                const cleanedText = text.replace(/[^\u4e00-\u9fa5a-zA-Z0-9\s]/g, '');
                cleanedText.split(/\s+/).filter(word => word.length > 1).forEach(word => {
                    words[word] = (words[word] || 0) + 1;
                });
            });

            const wordList = Object.entries(words).map(([text, count]) => ({ text, count }));

            const containerWidth = wordCloudContainer.offsetWidth;
            const containerHeight = wordCloudContainer.offsetHeight;

            function getRandomColor() {
                const letters = '0123456789ABCDEF';
                let color = '#';
                for (let i = 0; i < 6; i++) {
                    color += letters[Math.floor(Math.random() * 16)];
                }
                return color;
            }

            function createShatteredWord(wordObj) {
                const shatteredWordContainer = document.createElement('div');
                shatteredWordContainer.classList.add('shattered-word');
                shatteredWordContainer.style.fontSize = `${12 + Math.log2(wordObj.count) * 5}px`;
                shatteredWordContainer.style.color = getRandomColor();
                shatteredWordContainer.style.fontWeight = 'bold';
                // 隨機字形的設定已移除

                const wordText = wordObj.text;
                for (let i = 0; i < wordText.length; i++) {
                    const letterSpan = document.createElement('span');
                    letterSpan.classList.add('shattered-letter');
                    letterSpan.textContent = wordText[i];

                    // 隨機旋轉角度和微小位移
                    const rotateAngle = (Math.random() - 0.5) * 20; // -10 到 10 度
                    const translateX = (Math.random() - 0.5) * 5; // -2.5 到 2.5 像素
                    const translateY = (Math.random() - 0.5) * 5; // -2.5 到 2.5 像素

                    letterSpan.style.transform = `translate(${translateX}px, ${translateY}px) rotate(${rotateAngle}deg)`;
                    shatteredWordContainer.appendChild(letterSpan);
                }

                // 初始位置
                shatteredWordContainer.style.left = `${Math.random() * (containerWidth - shatteredWordContainer.offsetWidth)}px`;
                shatteredWordContainer.style.top = `${Math.random() * (containerHeight - shatteredWordContainer.offsetHeight)}px`;

                const speedX = (Math.random() - 0.5) * 2; // 隨機水平速度
                const speedY = (Math.random() - 0.5) * 2; // 隨機垂直速度

                function animateWord() {
                    let x = parseFloat(shatteredWordContainer.style.left);
                    let y = parseFloat(shatteredWordContainer.style.top);

                    x += speedX;
                    y += speedY;

                    // 邊界碰撞檢測
                    if (x < 50 || x > containerWidth - shatteredWordContainer.offsetWidth) {
                        speedX *= -100;
                    }
                    if (y < 50 || y > containerHeight - shatteredWordContainer.offsetHeight) {
                        speedY *= -100;
                    }

                    shatteredWordContainer.style.left = `${x}px`;
                    shatteredWordContainer.style.top = `${y}px`;

                    requestAnimationFrame(animateWord);
                }

                animateWord();
                return shatteredWordContainer;
            }

            wordList.forEach(wordObj => {
                const shatteredWord = createShatteredWord(wordObj);
                wordCloudContainer.appendChild(shatteredWord);
            });
        });
    </script>
</body>
</html>
