<!DOCTYPE html>
<html>
<head>
    <title>動態文字雲產生器</title>
    <style>
        body {
            font-family: sans-serif;
        }
        #wordCloudContainer {
            width: 100%; /* 或 80%，根據您的需求 */
            height: 400px; /* 或 90%，根據您的需求 */
            border: 1px solid #ccc;
            position: relative;
            overflow: hidden;
            background-color: #fff; /* 白色 */
            border-radius: 50%; /* 使方框變為橢圓形 */
            display: flex; /* 確保內容居中，視覺效果更佳 */
            justify-content: center;
            align-items: center;
        }
        .shattered-letter {
            display: inline-block;
            font-size: inherit;
            font-weight: inherit;
            color: inherit;
            position: absolute; /* 修改為 absolute 以便精確定位字母 */
        }
    </style>
</head>
<body>
    <button id="generateButton">產生文字雲</button>
    <div id="wordCloudContainer"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
        const generateButton = document.getElementById('generateButton');
        const wordCloudContainer = document.getElementById('wordCloudContainer');
        let excelData = [];

        window.onload = () => {
            loadDefaultExcelFile('demo.xlsx');
        };

        async function loadDefaultExcelFile(filename) {
            try {
                const response = await fetch(filename);
                if (!response.ok) {
                    throw new Error(`無法載入檔案: ${response.status}`);
                }
                const arrayBuffer = await response.arrayBuffer();
                const data = new Uint8Array(arrayBuffer);
                const workbook = XLSX.read(data, { type: 'array' });
                const sheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[sheetName];
                const range = XLSX.utils.decode_range(worksheet['!ref']);
                excelData = [];
                for (let rowNum = range.s.r; rowNum <= range.e.r; rowNum++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: rowNum, c: 0 });
                    const cell = worksheet[cellAddress];
                    if (cell && cell.v) {
                        excelData.push(cell.v);
                    }
                }
                if (excelData.length > 0) {
                    generateButton.disabled = false; // 啟用按鈕 (雖然現在是自動產生)
                    generateButton.click(); // 自動觸發產生文字雲
                } else {
                    alert("預設 Excel 檔案的第一欄沒有內容。");
                }
            } catch (error) {
                console.error("載入預設 Excel 檔案時發生錯誤:", error);
                alert(`載入預設 Excel 檔案時發生錯誤，請確認 ${filename} 檔案存在於相同路徑。`);
            }
        }

        generateButton.addEventListener('click', () => {
            wordCloudContainer.innerHTML = ''; // 清空之前的文字雲
            const words = {};
            excelData.forEach(text => {
                // 簡單的詞彙判斷
                const cleanedText = text.replace(/[^\u4e00-\u9fa5a-zA-Z0-9\s]/g, '');
                cleanedText.split(/\s+/).filter(word => word.length > 1).forEach(word => {
                    words[word] = (words[word] || 0) + 1;
                });
            });

            const wordList = Object.entries(words).map(([text, count]) => ({ text, count }));

            const containerWidth = wordCloudContainer.offsetWidth;
            const containerHeight = wordCloudContainer.offsetHeight;

            function getRandomColor() {
                const letters = '0123456789ABCDEF';
                let color = '#';
                for (let i = 0; i < 6; i++) {
                    color += letters[Math.floor(Math.random() * 16)];
                }
                return color;
            }

            function createShatteredWord(wordObj) {
                const shatteredWordContainer = document.createElement('div');
                shatteredWordContainer.style.fontSize = `${12 + Math.log2(wordObj.count) * 5}px`;
                shatteredWordContainer.style.color = getRandomColor();
                shatteredWordContainer.style.fontWeight = 'bold';
                shatteredWordContainer.style.fontFamily = "Microsoft YaHei", sans-serif; // 設定統一字形
                shatteredWordContainer.style.position = 'absolute'; // 確保容器是絕對定位

                const wordText = wordObj.text;
                const letters = [];
                for (let i = 0; i < wordText.length; i++) {
                    const letterSpan = document.createElement('span');
                    letterSpan.classList.add('shattered-letter');
                    letterSpan.textContent = wordText[i];

                    // 隨機旋轉角度和微小位移 (只在創建時設定)
                    const rotateAngle = (Math.random() - 0.5) * 20; // -10 到 10 度
                    const translateX = (Math.random() - 0.5) * 5; // -2.5 到 2.5 像素
                    const translateY = (Math.random() - 0.5) * 5; // -2.5 到 2.5 像素

                    letterSpan.style.transform = `translate(${translateX}px, ${translateY}px) rotate(${rotateAngle}deg)`;
                    shatteredWordContainer.appendChild(letterSpan);
                    letters.push(letterSpan);
                }

                // 初始位置
                shatteredWordContainer.style.left = `${Math.random() * (containerWidth - shatteredWordContainer.offsetWidth)}px`;
                shatteredWordContainer.style.top = `${Math.random() * (containerHeight - shatteredWordContainer.offsetHeight)}px`;

                let speedX = (Math.random() - 0.5) * 2; // 隨機水平速度
                let speedY = (Math.random() - 0.5) * 2; // 隨機垂直速度

                function resetWord() {
                    shatteredWordContainer.style.opacity = 0; // 消失
                    setTimeout(() => {
                        shatteredWordContainer.style.left = `${Math.random() * (containerWidth - shatteredWordContainer.offsetWidth)}px`;
                        shatteredWordContainer.style.top = `${Math.random() * (containerHeight - shatteredWordContainer.offsetHeight)}px`;
                        speedX = (Math.random() - 0.5) * 2; // 重新賦予隨機速度
                        speedY = (Math.random() - 0.5) * 2;
                        shatteredWordContainer.style.opacity = 1; // 出現
                    }, 200); // 延遲 200 毫秒後重新出現
                }

                function animateWord() {
                    let x = parseFloat(shatteredWordContainer.style.left);
                    let y = parseFloat(shatteredWordContainer.style.top);

                    x += speedX;
                    y += speedY;

                    // 邊界碰撞檢測
                    if (x < 0 || x > containerWidth - shatteredWordContainer.offsetWidth) {
                        resetWord();
                        return;
                    }
                    if (y < 0 || y > containerHeight - shatteredWordContainer.offsetHeight) {
                        resetWord();
                        return;
                    }

                    shatteredWordContainer.style.left = `${x}px`;
                    shatteredWordContainer.style.top = `${y}px`;

                    requestAnimationFrame(animateWord);
                }

                animateWord();
                return shatteredWordContainer;
            }

            wordList.forEach(wordObj => {
                const shatteredWord = createShatteredWord(wordObj);
                wordCloudContainer.appendChild(shatteredWord);
            });
        });
    </script>
</body>
</html>
