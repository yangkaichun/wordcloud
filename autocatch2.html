<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>國家衛生研究院AI小管家_用戶提問文字雲生成器</title>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-cloud@1.2.5/build/d3.layout.cloud.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8ec 100%);
            min-height: 100vh;
        }
        
        .tech-element {
            position: absolute;
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.1) 0%, rgba(41, 128, 185, 0.1) 100%);
            border-radius: 50%;
            pointer-events: none;
            z-index: -1;
        }
        
        .tech-element-1 {
            width: 300px;
            height: 300px;
            top: -150px;
            right: -100px;
            animation: float 15s infinite ease-in-out;
        }
        
        .tech-element-2 {
            width: 200px;
            height: 200px;
            bottom: -100px;
            left: -80px;
            animation: float 12s infinite ease-in-out reverse;
        }
        
        @keyframes float {
            0% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(10px, 15px) rotate(5deg); }
            50% { transform: translate(0, 25px) rotate(0deg); }
            75% { transform: translate(-10px, 15px) rotate(-5deg); }
            100% { transform: translate(0, 0) rotate(0deg); }
        }
        
        .btn {
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .btn:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: all 0.4s ease;
        }
        
        .btn:hover:before {
            left: 100%;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="flex flex-col items-center">
    <div class="tech-element tech-element-1"></div>
    <div class="tech-element tech-element-2"></div>
    
    <header class="w-full bg-gradient-to-r from-white/90 to-blue-50/90 py-4 shadow-md mb-8 z-10">
        <div class="max-w-7xl mx-auto px-4 flex items-center">
            <img id="logoImage" class="h-14 mr-4" src="https://www.nhri.edu.tw/userfiles/images/Logo.png" alt="國家衛生研究院">
            <h1 class="text-xl md:text-2xl font-bold text-blue-700">國家衛生研究院AI小管家_用戶提問文字雲生成器(自動擷取)</h1>
        </div>
    </header>
    
    <div class="max-w-7xl w-full px-4 flex flex-col items-center">
        <div class="flex flex-wrap justify-center gap-4 mb-8 w-full">
            <input type="file" id="fileInput" accept=".xlsx, .xls" class="hidden" />
            <button id="fileBtn" class="btn bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white px-6 py-3 rounded-full shadow-md hover:shadow-lg transform hover:-translate-y-0.5 active:translate-y-0.5 min-w-[180px]">
                選擇Excel檔案
            </button>
            <button id="keywordsBtn" class="btn bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white px-6 py-3 rounded-full shadow-md hover:shadow-lg transform hover:-translate-y-0.5 active:translate-y-0.5 min-w-[180px]">
                產生關鍵詞文字雲
            </button>
            <button id="sentenceBtn" class="btn bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white px-6 py-3 rounded-full shadow-md hover:shadow-lg transform hover:-translate-y-0.5 active:translate-y-0.5 min-w-[180px]">
                產生整句語意
            </button>
        </div>
        
        <div class="w-full h-[70vh] relative bg-white rounded-2xl overflow-hidden shadow-xl mb-4">
            <div id="wordCloudContainer" class="w-full h-full"></div>
            <div id="loading" class="absolute inset-0 bg-white/80 flex flex-col items-center justify-center z-20 hidden">
                <div class="loading-spinner mb-4"></div>
                <div class="text-xl text-gray-700">處理中，請稍候...</div>
            </div>
        </div>
        
        <div id="status" class="text-center text-gray-600 mb-8">
            準備就緒。請選擇Excel檔案或使用預設資料。
        </div>
        
        <div class="bg-white p-6 rounded-xl shadow-md w-full max-w-4xl mb-8">
            <h3 class="text-lg font-bold text-blue-700 border-b border-gray-100 pb-2 mb-4">使用說明</h3>
            <ul class="list-disc pl-6 space-y-2">
                <li>選擇Excel檔案：上傳包含用戶提問的Excel檔案，第一列應是標題，第一欄包含要分析的文本。</li>
                <li>產生關鍵詞文字雲：自動處理文本（移除數字和英文，進行翻譯和NLP處理），顯示關鍵詞文字雲。</li>
                <li>產生整句語意：保留完整句子，顯示較長的語句。</li>
                <li>預設資料：若未上傳Excel，將使用預設的遠程資料。</li>
                <li>文字處理流程：刪除數字和英文 → 翻譯成英文 → NLP處理提取名詞 → 翻譯回繁體中文 → 產生文字雲。</li>
            </ul>
        </div>
    </div>

    <script>
        // 全局變量
        const EXCEL_URL = 'https://cmm.ai:9999/export_records?start_date=2024-10-01&end_date=2025-12-31';
        const CHINESE_FONTS = [
            '"Noto Sans TC", sans-serif',
            '"Microsoft JhengHei", sans-serif',
            '"Microsoft YaHei", sans-serif',
            '"SimHei", sans-serif',
            '"SimSun", sans-serif',
            '"KaiTi", sans-serif',
            '"STKaiti", sans-serif',
            '"NSimSun", sans-serif',
            '"PMingLiU", sans-serif',
            '"MingLiU", sans-serif'
        ];
        let excelData = null;
        let words = [];
        let svg = null;

        // DOM 元素
        const fileInput = document.getElementById('fileInput');
        const fileBtn = document.getElementById('fileBtn');
        const keywordsBtn = document.getElementById('keywordsBtn');
        const sentenceBtn = document.getElementById('sentenceBtn');
        const statusDiv = document.getElementById('status');
        const loadingDiv = document.getElementById('loading');
        const wordCloudContainer = document.getElementById('wordCloudContainer');

        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            // 設置事件監聽
            fileBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);
            keywordsBtn.addEventListener('click', () => processExcelData('keywords'));
            sentenceBtn.addEventListener('click', () => processExcelData('sentence'));
            
            // 自動載入遠程Excel資料
            loadRemoteExcel();
            
            // 初始化SVG
            initSvg();
            
            // 調整視窗大小時重繪文字雲
            window.addEventListener('resize', () => {
                if (words.length > 0) {
                    renderWordCloud(words);
                }
            });
        });

        // 初始化SVG
        function initSvg() {
            // 清除現有的SVG
            if (svg) {
                svg.remove();
            }
            
            const width = wordCloudContainer.clientWidth;
            const height = wordCloudContainer.clientHeight;
            
            svg = d3.select("#wordCloudContainer")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", `translate(${width/2},${height/2})`);
        }

        // 載入遠程Excel檔案
        async function loadRemoteExcel() {
            showLoading("正在載入遠程Excel資料...");
            
            try {
                const response = await fetch(EXCEL_URL);
                if (!response.ok) {
                    throw new Error('無法獲取遠程資料');
                }
                
                const arrayBuffer = await response.arrayBuffer();
                const data = new Uint8Array(arrayBuffer);
                parseExcelData(data);
                hideLoading();
                updateStatus("已成功載入遠程資料，準備就緒。");
                
                // 自動產生關鍵詞文字雲
                setTimeout(() => processExcelData('keywords'), 500);
            } catch (error) {
                console.error('載入遠程Excel失敗:', error);
                updateStatus("無法載入遠程資料，請嘗試上傳本地Excel檔案。");
                hideLoading();
            }
        }

        // 處理本地Excel檔案選擇
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            showLoading("正在讀取Excel檔案...");
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const data = new Uint8Array(e.target.result);
                parseExcelData(data);
                updateStatus(`已載入檔案: ${file.name}`);
                hideLoading();
            };
            
            reader.onerror = function() {
                updateStatus("讀取檔案時發生錯誤。");
                hideLoading();
            };
            
            reader.readAsArrayBuffer(file);
        }

        // 解析Excel資料
        function parseExcelData(data) {
            try {
                const workbook = XLSX.read(data, { type: 'array' });
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                
                // 將工作表轉換為JSON
                excelData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                
                // 檢查是否有資料
                if (!excelData || excelData.length === 0) {
                    updateStatus("Excel檔案沒有任何資料。");
                    return;
                }
                
                updateStatus(`Excel資料載入成功，共有 ${excelData.length} 行資料。`);
            } catch (error) {
                console.error('解析Excel失敗:', error);
                updateStatus("解析Excel檔案時發生錯誤。");
            }
        }

        // 處理Excel資料生成文字雲
        async function processExcelData(type) {
            if (!excelData || excelData.length === 0) {
                updateStatus("請先載入Excel資料。");
                return;
            }
            
            showLoading(type === 'keywords' ? "正在產生關鍵詞文字雲..." : "正在產生整句語意...");
            
            // 收集第一欄的所有文本
            let allTexts = [];
            for (let i = 0; i < excelData.length; i++) {
                const row = excelData[i];
                if (row && row.length > 0 && row[0]) {
                    const text = String(row[0]).trim();
                    if (text) {
                        allTexts.push(text);
                    }
                }
            }
            
            if (allTexts.length === 0) {
                updateStatus("在Excel資料中找不到有效的文本。");
                hideLoading();
                return;
            }
            
            try {
                // 根據類型處理文本
                if (type === 'keywords') {
                    await processKeywords(allTexts);
                } else {
                    await processSentences(allTexts);
                }
                hideLoading();
            } catch (error) {
                console.error('處理資料失敗:', error);
                updateStatus("處理資料時發生錯誤。");
                hideLoading();
            }
        }

        // 處理關鍵詞
        async function processKeywords(texts) {
            updateStatus("正在處理文本並提取關鍵詞...");
            
            // 1. 預處理文本：刪除數字和英文
            const cleanedTexts = texts.map(text => preprocessText(text));
            console.log("預處理後文本示例:", cleanedTexts.slice(0, 3));
            
            // 2. 翻譯成英文
            updateStatus("正在將文本翻譯成英文...");
            const englishTexts = [];
            for (const text of cleanedTexts) {
                if (text.trim()) {
                    try {
                        const englishText = await translateToEnglish(text);
                        englishTexts.push(englishText);
                    } catch (error) {
                        console.error("翻譯失敗:", error);
                    }
                }
            }
            console.log("英文翻譯示例:", englishTexts.slice(0, 3));
            
            // 3. NLP處理，只提取名詞
            updateStatus("正在進行NLP處理，提取名詞...");
            const extractedNouns = englishTexts.map(text => extractNouns(text));
            console.log("提取名詞後示例:", extractedNouns.slice(0, 3));
            
            // 4. 翻譯回繁體中文
            updateStatus("正在將處理後的文本翻譯回繁體中文...");
            const chineseTexts = [];
            for (const text of extractedNouns) {
                if (text.trim()) {
                    try {
                        const chineseText = await translateToChinese(text);
                        chineseTexts.push(chineseText);
                    } catch (error) {
                        console.error("翻譯失敗:", error);
                    }
                }
            }
            console.log("翻譯回中文示例:", chineseTexts.slice(0, 3));
            
            // 5. 分詞和統計詞頻
            const wordFrequency = {};
            const stopWords = getStopWords();
            
            chineseTexts.forEach(text => {
                // 簡單的分詞（依空格和標點符號）
                const segments = text.split(/[\s.,?!;:"'，。？！；：""'']/);
                
                segments.forEach(segment => {
                    if (!segment.trim() || stopWords.has(segment) || segment.length < 2) {
                        return;
                    }
                    
                    // 進一步將長詞組拆分為2-3字詞
                    if (segment.length > 3) {
                        for (let i = 0; i < segment.length - 1; i++) {
                            // 提取2-3字詞
                            if (i < segment.length - 2) {
                                const threeChars = segment.substr(i, 3);
                                if (!/^[\u4e00-\u9fa5]+$/.test(threeChars) || stopWords.has(threeChars)) continue;
                                wordFrequency[threeChars] = (wordFrequency[threeChars] || 0) + 1;
                            }
                            
                            const twoChars = segment.substr(i, 2);
                            if (!/^[\u4e00-\u9fa5]+$/.test(twoChars) || stopWords.has(twoChars)) continue;
                            wordFrequency[twoChars] = (wordFrequency[twoChars] || 0) + 1;
                        }
                    } else {
                        // 直接計算短詞頻率
                        if (!/^[\u4e00-\u9fa5]+$/.test(segment)) return;
                        wordFrequency[segment] = (wordFrequency[segment] || 0) + 1;
                    }
                });
            });
            
            // 轉換為數組並按詞頻排序
            const wordArray = Object.entries(wordFrequency)
                .filter(([word, freq]) => freq > 1 && word.length >= 2 && /^[\u4e00-\u9fa5]+$/.test(word))
                .sort((a, b) => b[1] - a[1])
                .slice(0, 100);
            
            // 創建詞雲項目
            createWordCloudItems(wordArray);
        }

        // 處理整句語意
        async function processSentences(texts) {
            // 去重和過濾
            const uniqueSentences = new Set();
            const sentenceFrequency = {};
            
            texts.forEach(text => {
                // 移除所有英文和數字
                text = preprocessText(text);
                
                // 如果是純中文句子且長度合適，則保留
                if (/^[\u4e00-\u9fa5，。！？、：；""''（）【】《》]+$/.test(text) && text.length > 3 && text.length < 20) {
                    uniqueSentences.add(text);
                    
                    if (sentenceFrequency[text]) {
                        sentenceFrequency[text]++;
                    } else {
                        sentenceFrequency[text] = 1;
                    }
                }
            });
            
            // 轉換為數組並按頻率排序
            const sentenceArray = Object.entries(sentenceFrequency)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 50);
            
            // 創建詞雲項目
            createWordCloudItems(sentenceArray);
        }

        // 創建詞雲項目並渲染
        function createWordCloudItems(items) {
            if (!items || items.length === 0) {
                updateStatus("沒有足夠的資料生成文字雲。");
                return;
            }
            
            // 獲取最大和最小頻率
            const frequencies = items.map(item => item[1]);
            const maxFreq = Math.max(...frequencies);
            const minFreq = Math.min(...frequencies);
            
            // 創建詞雲項目
            words = items.map(([text, freq]) => {
                // 計算字體大小（根據頻率）
                const fontSize = calculateFontSize(freq, minFreq, maxFreq);
                
                // 隨機選擇字體
                const fontFamily = CHINESE_FONTS[Math.floor(Math.random() * CHINESE_FONTS.length)];
                
                // 隨機顏色
                const hue = Math.floor(Math.random() * 360);
                const saturation = 70 + Math.random() * 30;
                const lightness = 45 + Math.random() * 10;
                const color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                
                return {
                    text,
                    size: fontSize,
                    font: fontFamily,
                    color: color,
                    frequency: freq
                };
            });
            
            // 渲染詞雲
            renderWordCloud(words);
            updateStatus(`已生成 ${words.length} 個項目的文字雲。`);
        }

        // 渲染詞雲
        function renderWordCloud(words) {
            if (!words || words.length === 0) return;
            
            // 重新初始化SVG以獲取正確尺寸
            initSvg();
            
            const width = wordCloudContainer.clientWidth;
            const height = wordCloudContainer.clientHeight;
            
            // 創建布局
            const layout = d3.layout.cloud()
                .size([width, height])
                .words(words)
                .padding(5)
                .rotate(0)  // 不旋轉中文
                .font(d => d.font)
                .fontSize(d => d.size)
                .spiral("archimedean")  // 螺旋布局
                .on("end", draw);
                
            // 開始計算布局
            layout.start();
            
            // 繪製詞雲
            function draw(words) {
                svg.selectAll("*").remove();
                
                // 繪製橢圓邊界
                svg.append("ellipse")
                    .attr("cx", 0)
                    .attr("cy", 0)
                    .attr("rx", width * 0.45)
                    .attr("ry", height * 0.45)
                    .attr("fill", "none")
                    .attr("stroke", "rgba(41, 128, 185, 0.3)")
                    .attr("stroke-width", 2);
                
                // 繪製詞雲
                svg.selectAll("text")
                    .data(words)
                    .enter()
                    .append("text")
                    .style("font-size", d => `${d.size}px`)
                    .style("font-family", d => d.font)
                    .style("fill", d => d.color)
                    .attr("text-anchor", "middle")
                    .attr("transform", d => `translate(${d.x},${d.y})`)
                    .text(d => d.text);
            }
        }

        // 文本預處理：刪除數字和英文
        function preprocessText(text) {
            if (!text) return '';
            
            // 刪除中文數字
            const chineseNums = ['零', '一', '二', '三', '四', '五', '六', '七', '八', '九', '十', '百', '千', '萬', '億'];
            chineseNums.forEach(num => {
                text = text.replace(new RegExp(num, 'g'), '');
            });
            
            // 刪除阿拉伯數字
            text = text.replace(/[0-9]+/g, '');
            
            // 刪除英文字
            text = text.replace(/[a-zA-Z]+/g, '');
            
            return text.trim();
        }

        // 提取英文文本中的名詞
        function extractNouns(englishText) {
            if (!englishText) return '';
            
            // 常見英文停用詞和非名詞
            const stopWords = [
                "the", "a", "an", "and", "or", "but", "is", "are", "was", "were", "be", "being", "been",
                "have", "has", "had", "do", "does", "did", "will", "would", "should", "can", "could",
                "may", "might", "must", "shall", "to", "of", "for", "with", "about", "against", "between",
                "into", "through", "during", "before", "after", "above", "below", "from", "up", "down",
                "in", "out", "on", "off", "over", "under", "again", "further", "then", "once", "here",
                "there", "when", "where", "why", "how", "all", "any", "both", "each", "few", "more",
                "most", "other", "some", "such", "no", "nor", "not", "only", "own", "same", "so", "than",
                "too", "very", "s", "t", "can", "will", "just", "don", "don't", "should", "now", "d", "ll",
                "m", "o", "re", "ve", "y", "ain", "aren", "aren't", "couldn", "couldn't", "didn", "didn't",
                "doesn", "doesn't", "hadn", "hadn't", "hasn", "hasn't", "haven", "haven't", "isn", "isn't",
                "ma", "mightn", "mightn't", "mustn", "mustn't", "needn", "needn't", "shan", "shan't",
                "shouldn", "shouldn't", "wasn", "wasn't", "weren", "weren't", "won", "won't", "wouldn", "wouldn't",
                // 動詞 (部分)
                "go", "goes", "going", "went", "gone", "say", "says", "saying", "said", "see", "sees", "seeing",
                "saw", "seen", "get", "gets", "getting", "got", "gotten", "make", "makes", "making", "made",
                "know", "knows", "knowing", "knew", "known", "think", "thinks", "thinking", "thought",
                "take", "takes", "taking", "took", "taken", "come", "comes", "coming", "came", "want", "wants",
                "wanting", "wanted", "use", "uses", "using", "used", "find", "finds", "finding", "found",
                "give", "gives", "giving", "gave", "given", "tell", "tells", "telling", "told", "work", "works",
                "working", "worked", "call", "calls", "calling", "called", "try", "tries", "trying", "tried",
                "ask", "asks", "asking", "asked", "need", "needs", "needing", "needed", "feel", "feels",
                "feeling", "felt", "seem", "seems", "seeming", "seemed", "like", "likes", "liking", "liked"
            ];
            
            // 簡單的句子分詞
            const words = englishText.split(/\s+/)
                .map(word => word.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, "").toLowerCase())
                .filter(word => word.length > 2 && !stopWords.includes(word));
            
            return words.join(" ");
        }

        // 使用Google Cloud Translation API進行中文到英文的翻譯 (模擬)
        async function translateToEnglish(text) {
            if (!text || !text.trim()) return '';
            
            // 注意：在實際應用中，應使用後端API來處理翻譯請求，以保護API密鑰
            // 此處使用模擬翻譯
            try {
                // 使用Google翻譯API的免費版本
                // 在實際應用中，這裡應該通過後端API調用實際的Google Cloud Translation API
                console.log("翻譯中文到英文:", text.substring(0, 30) + (text.length > 30 ? "..." : ""));
                
                // 這裡只是模擬，實際應用中應替換為真正的API調用
                // 模擬延遲
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // 簡單的關鍵詞對應 (模擬翻譯)
                // 在實際應用中應移除此代碼並使用真正的翻譯API
                const translations = {
                    "健康": "health",
                    "醫療": "medical care",
                    "疾病": "disease",
                    "症狀": "symptom",
                    "治療": "treatment",
                    "藥物": "medicine",
                    "飲食": "diet",
                    "運動": "exercise",
                    "睡眠": "sleep",
                    "壓力": "stress",
                    "心理": "psychology",
                    "研究": "research",
                    "問題": "problem",
                    "建議": "suggestion",
                    "如何": "how to",
                    "為什麼": "why",
                    "何時": "when",
                    "醫院": "hospital",
                    "醫生": "doctor",
                    "護士": "nurse",
                    "疫苗": "vaccine",
                    "檢查": "examination",
                    "測試": "test",
                    "報告": "report"
                };
                
                let translatedText = text;
                Object.entries(translations).forEach(([chinese, english]) => {
                    translatedText = translatedText.replace(new RegExp(chinese, 'g'), english);
                });
                
                return translatedText;
            } catch (error) {
                console.error("翻譯到英文失敗:", error);
                return text;
            }
        }

        // 使用Google Cloud Translation API進行英文到中文的翻譯 (模擬)
        async function translateToChinese(text) {
            if (!text || !text.trim()) return '';
            
            try {
                console.log("翻譯英文到中文:", text.substring(0, 30) + (text.length > 30 ? "..." : ""));
                
                // 模擬延遲
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // 簡單的關鍵詞對應 (模擬翻譯)
                const translations = {
                    "health": "健康",
                    "medical care": "醫療",
                    "disease": "疾病",
                    "symptom": "症狀",
                    "treatment": "治療",
                    "medicine": "藥物",
                    "diet": "飲食",
                    "exercise": "運動",
                    "sleep": "睡眠",
                    "stress": "壓力",
                    "psychology": "心理",
                    "research": "研究",
                    "problem": "問題",
                    "suggestion": "建議",
                    "how to": "如何",
                    "why": "為什麼",
                    "when": "何時",
                    "hospital": "醫院",
                    "doctor": "醫生",
                    "nurse": "護士",
                    "vaccine": "疫苗",
                    "examination": "檢查",
                    "test": "測試",
                    "report": "報告"
                };
                
                let translatedText = text;
                Object.entries(translations).forEach(([english, chinese]) => {
                    translatedText = translatedText.replace(new RegExp(english, 'gi'), chinese);
                });
                
                return translatedText;
            } catch (error) {
                console.error("翻譯到中文失敗:", error);
                return text;
            }
        }

        // 計算字體大小
        function calculateFontSize(freq, minFreq, maxFreq) {
            // 字體大小範圍
            const minFontSize = 14;
            const maxFontSize = 60;
            
            // 如果只有一個頻率，直接返回中間大小
            if (minFreq === maxFreq) {
                return (minFontSize + maxFontSize) / 2;
            }
            
            // 根據頻率計算大小
            const normalized = (freq - minFreq) / (maxFreq - minFreq);
            return minFontSize + normalized * (maxFontSize - minFontSize);
        }

        // 獲取停用詞表
        function getStopWords() {
            // 中文常見停用詞
            const stopWordsList = [
                "的", "了", "和", "是", "在", "我", "有", "你", "他", "她", "它", "們", "這", "那", "就",
                "也", "而", "但", "於", "以", "與", "或", "等", "如", "為", "與", "都", "要", "各", "讓",
                "得", "著", "給", "從", "到", "中", "上", "下", "前", "後", "內", "外", "其", "只", "因",
                "為了", "所以", "因為", "可以", "不能", "沒有", "什麼", "如何", "怎麼", "為什麼", "哪裡",
                "請問", "告訴我", "能否", "是否", "能不能", "有沒有", "如果", "當", "而且", "並且", "不但",
                "雖然", "可是", "不過", "然而", "因此", "所以", "只要", "只有", "除了", "一些", "一個", "一樣",
                "一種", "我們", "你們", "他們", "她們", "它們", "那些", "這些", "每個", "每種", "每次", "每當"
            ];
            
            return new Set(stopWordsList);
        }

        // 顯示載入中
        function showLoading(message) {
            loadingDiv.classList.remove('hidden');
            const loadingText = loadingDiv.querySelector('div:last-child');
            if (loadingText) {
                loadingText.textContent = message || "處理中，請稍候...";
            }
        }

        // 隱藏載入中
        function hideLoading() {
            loadingDiv.classList.add('hidden');
        }

        // 更新狀態信息
        function updateStatus(message) {
            statusDiv.textContent = message;
        }
    </script>
</body>
</html>
